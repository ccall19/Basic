Python 数据结构实现速览
========================

关注点说明：主体写实现细节（存储布局、扩容策略、算法），特性只占少量篇幅，便于定位性能与局限。

序列族（list/tuple/str/bytes/bytearray）
---------------------------------------
- list：连续内存的动态数组，元素是 PyObject* 指针；追加时按 over-allocation 策略一次性扩容（CPython 3.12 约增长 12.5%+常量），末尾 append/pop 均摊 $O(1)$，中间插入/删除需整体移动 $O(n)$，len 缓存 $O(1)$。
- tuple：与 list 相同的连续数组，但大小固定、不可变，内存头部不留冗余空间；可用作 dict/set 键。
- str：PEP 393 “灵活字符串表示”，可能使用 1/2/4 字节元素存储 Unicode，尾部携带缓存的哈希值；不可变，切片创建新对象（共享不发生）。
- bytes：不可变的 uint8 序列，紧凑连续内存；bytearray：可变版本，内部也是可增长的连续缓冲（类似 list 的 over-allocation），支持就地修改。

映射与集合（dict/set/frozenset）
-------------------------------
- dict：紧凑哈希表，维护插入顺序。核心由两个数组组成：
	- indices（稀疏表，存储 entry 索引或 EMPTY 状态），使用开放寻址 + perturb 算法解决冲突。
	- entries（紧凑数组，存 key、value、cached-hash），按插入顺序追加，删除仅标记索引为空，entry 保留以维持顺序视图。
	负载因子约 2/3 触发扩容（尺寸翻倍），均摊查找/插入/删除 $O(1)$，遍历 $O(n)$。
- set：与 dict 同样的哈希表与探测逻辑，但 entry 只存 key；frozenset 只读、可哈希。
- 可哈希要求：对象 __hash__ 稳定且与 __eq__ 一致；可变容器（list/dict/set）默认不可哈希，tuple/bytes/str 可哈希（内容决定）。

队列与堆（deque/heapq/queue）
-----------------------------
- collections.deque：分段环形缓冲（块链表，每块固定大小，如 64 槽），两端操作 $O(1)$；rotate 通过调整头尾指针实现，不移动元素；可选 maxlen 自动丢弃旧元素。
- heapq：基于 list 的最小二叉堆，父子索引关系 i -> 2i+1/2i+2；push/pop $O(\log n)$，heapify $O(n)$，不支持自动删除任意元素（需惰性删除或重建）。
- queue.Queue/LifoQueue/PriorityQueue：在 heapq 或 list 基础上加锁与条件变量，线程安全但单线程下有额外开销。

数组与缓冲（array/memoryview）
-----------------------------
- array.array：定类型 C 连续数组，元素紧凑存储，支持就地扩容（类似 list 的 over-allocation）；适合大量数值且减少对象头开销。
- memoryview：基于缓冲协议的零拷贝视图，可对支持缓冲的对象（bytes/bytearray/array/numpy 等）做切片、子视图，读写取决于底层可写性；适合避免大数据复制。

补充：排序实现
--------------
- list.sort / sorted 使用 Timsort：融合归并 + 插入排序，稳定；最佳接近 $O(n)$（已排序），最坏 $O(n \log n)$；依赖 key 函数比实现 __lt__ 更高效且简洁。

常用判断速览（轻量特性）
-----------------------
- 可变：list、dict、set、bytearray、deque、array；不可变：tuple、str、bytes、frozenset。
- 保序：list、tuple、str/bytes/bytearray、dict（3.7+）、deque、array。
- 典型选择：
	- 随机读多、尾部写多：list；两端频繁：deque。
	- 映射/集合查找：dict/set；需要不可变集合：frozenset。
	- 二进制/零拷贝：bytearray + memoryview；数值致密存储：array。

调优与陷阱（实现相关）
---------------------
- 不要在迭代 dict/set 时删除/插入同一对象，可能触发 RuntimeError 或逻辑错；先收集再批量修改。
- 长期增长缩减的 list 可在大删除后 `lst[:] = lst` 或 `lst = lst.copy()` 触发收缩（否则容量可能过大）。
- dict 删除不会立即回收 entry 槽位，频繁删后可用 `d = dict(d)` 重建压缩。
- 大数据切片会复制内存，字符串切片同样；如需零拷贝共享，用 memoryview（对二进制）或管理索引区间（对 str）。
- 自定义对象参与哈希表：实现 __hash__ 与 __eq__ 保持一致，且哈希值应在生命周期内不变。
