# Python 数据结构总述

本文档主要总结 Python 内置数据结构的底层实现原理，便于快速查阅和复习。

## 1. List (列表)
*   **底层实现**: **动态数组 (Dynamic Array)**。
    *   本质是一个 C 语言的结构体，包含指向指针数组的指针、当前长度 (`ob_size`) 和分配的容量 (`allocated`)。
    *   存储的是**对象的引用 (指针)**，而非对象本身。
    *   内存地址是连续的。
*   **扩容机制**:
    *   **预分配 (Over-allocation)**: 为了避免每次 `append` 都重新分配内存，List 会申请比实际需求更多的内存。
    *   **增长策略**: 当容量不足时，新容量大约是旧容量的 **1.125 倍** (具体公式类似 `new_size = old_size + (old_size >> 3) + 6`)。
    *   扩容涉及：申请新内存 -> 拷贝旧数据 -> 释放旧内存。
*   **时间复杂度**:
    *   索引访问 (`list[i]`): **O(1)**。
    *   尾部追加 (`append`): **摊销 O(1)**。
    *   头部/中间插入或删除 (`insert`, `pop(0)`): **O(n)** (需要移动后续所有元素的指针)。

## 2. Tuple (元组)
*   **底层实现**: **静态数组**。
    *   结构体与 List 类似，但没有 `allocated` 字段，因为一旦创建，大小固定。
    *   不可变性是指存储的**引用地址不可变** (如果引用指向一个可变对象如 List，该 List 内容可变)。
*   **性能优化 (Resource Caching)**:
    *   **Free List**: Python 解释器会缓存并复用被回收的小元组 (通常长度 < 20) 的内存块。
    *   因此，创建和销毁 Tuple 通常比 List 更快，且内存碎片更少。

## 3. Dict (字典)
*   **底层实现**: **哈希表 (Hash Table)**。
*   **冲突解决**: **开放寻址法 (Open Addressing)**。
    *   不同于 Java HashMap 的链地址法。
    *   当发生哈希冲突时，通过二次探查 (Quadratic Probing) 或伪随机探查序列寻找下一个空槽。
*   **结构演变 (Python 3.6+ Compact Dict)**:
    *   为了节省内存并保持插入顺序，将存储结构分离为两个数组：
        1.  **Indices (稀疏数组)**: 存储哈希值映射到的 `Entries` 索引。
        2.  **Entries (稠密数组)**: 按**插入顺序**紧凑存储 `(hash, key_ptr, value_ptr)`。
*   **扩容与缩容**:
    *   **负载因子**: 当使用率超过 **2/3** 时触发扩容。
    *   扩容通常按 **2 倍** 增长。
    *   扩容需要重新计算所有 Key 的哈希位置 (Rehash)。
*   **时间复杂度**:
    *   查找/插入/删除: 平均 **O(1)**，最坏 **O(n)**。

## 4. Set (集合)
*   **底层实现**: **哈希表 (Hash Table)**。
    *   实现原理与 Dict 几乎一致。
    *   区别在于 Set 的 Entry 只存储 `(hash, key_ptr)`，没有 Value。
    *   利用 Dict 的 Key 唯一性来实现去重。
*   **特性**:
    *   元素必须是**可哈希 (Hashable)** 的。
    *   **无序性**: 尽管 Compact Dict 带来了有序，但 Set 语义上不保证顺序。

## 5. Deque (双端队列 - collections.deque)
*   **底层实现**: **双向链表 (Doubly Linked List)** (实际上是**数组块的链表**)。
    *   由多个定长的内存块 (Block) 组成，块之间通过双向指针连接。
    *   每个 Block 内部像数组一样存储元素。
*   **特性**:
    *   两端操作 (`append`, `pop`, `appendleft`, `popleft`): **O(1)**。
    *   中间访问/索引: **O(n)** (需要遍历链表找到对应的 Block)。
