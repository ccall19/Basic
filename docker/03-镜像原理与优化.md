# 镜像原理与优化（分层、缓存、瘦身）

学习目标（读完你应该能做到）：

- 理解镜像分层与缓存：为什么改一行代码会导致某一层重新构建
- 会用 `docker history/inspect/system df` 定位镜像体积与磁盘占用
- 熟悉 3～5 个常见瘦身策略（.dockerignore、多阶段、清理缓存等）

## 1. 镜像是“分层的只读文件系统”

- 每个 Dockerfile 指令（尤其 RUN/COPY/ADD）通常会产生一层
- 容器运行时在镜像层之上叠加一个可写层

理解这点能解释：

- 为什么“删除文件”不一定让镜像变小（删除发生在后续层）
- 为什么把依赖安装放前面可以提升缓存命中

---

## 2. tag、digest 与不可变性

- `repo:tag` 是“指针”，可以移动
- `@sha256:...` digest 才是内容地址（不可变）

---

## 3. 镜像瘦身常用手段

1) 选择合适基础镜像
- `alpine` 很小，但可能遇到 musl/兼容性问题
- `slim` 往往是“体积 vs 兼容性”更平衡的选择

2) 合并 RUN 并清理缓存
- apt/yum/apk 的缓存、构建产物、临时文件

3) 多阶段构建
- builder 阶段装编译工具
- runtime 阶段只复制产物

4) 只 COPY 必要文件 + 配好 `.dockerignore`

---

## 4. 构建缓存与 CI

- 缓存取决于指令序列与上下文内容是否变化
- 把变化频率低的步骤（依赖安装）提前
- 把变化频率高的步骤（源码 COPY）放后面

---

## 5. 你可以用的检查命令

```bash
docker images
docker history <image>
docker inspect <image>

docker system df
```
