# Git 底层对象模型

Git 的核心是一个简单的键值对数据库（Key-Value Store）。在 Git 的底层，所有内容都存储为对象，主要包括三种核心对象：**Blob**、**Tree** 和 **Commit**。

---

## 1. Blob (Binary Large Object) —— 数据对象

**Blob 只存储文件的内容**，不存储文件名、权限或路径。

- **原理**：Git 对文件内容进行 SHA-1 哈希计算，得到一个 40 位的十六进制字符串作为 Key。
- **特点**：
    - 相同内容的文件在 Git 中只存储一份（去重）。
    - 只要内容变了，哈希值就变，生成新的 Blob。

---

## 2. Tree (树对象) —— 目录结构

**Tree 解决了文件名和目录结构的问题。** 它像一个目录列表。

- **内容**：一个 Tree 对象包含：
    - 文件的权限（mode）。
    - 对象的类型（blob 或 tree）。
    - 对象的哈希值（SHA-1）。
    - 文件名或目录名。
- **为什么需要 Tree？**
    - **管理层级**：Tree 可以嵌套，从而表示复杂的文件夹结构。
    - **解耦文件名与内容**：Blob 只存内容，文件名存放在 Tree 中。这意味着相同内容的文件可以有不同的名字，且在底层只占用一份空间。

---

## 3. Commit (提交对象) —— 快照与元数据

**Commit 代表了项目的一个特定版本快照。**

- **内容**：
    - **指向一个 Tree 对象**：代表该版本对应的根目录快照。
    - **作者与提交者信息**：谁在什么时候提交的。
    - **提交说明**：Commit Message。
    - **父提交（Parent）**：指向前一个 Commit 的哈希值，从而形成版本历史链条。

---

## 总结：它们是如何协作的？

当你执行 `git commit` 时，Git 会完成以下操作：

1.  **存储内容**：将修改的文件存为 **Blob**。
2.  **记录结构**：创建一个或多个 **Tree** 对象，记录文件名并指向对应的 Blob。
3.  **创建快照**：创建一个 **Commit** 对象，指向根 Tree，并记录父提交。

### 关系图示：

```text
Commit (提交)
  │
  └── Tree (根目录)
        │
        ├── Blob (文件A内容)
        └── Tree (子目录)
              │
              └── Blob (文件B内容)
```

这种结构使得 Git 能够高效地处理版本切换：只需改变 HEAD 指向的 Commit，然后根据 Tree 结构还原文件即可。
